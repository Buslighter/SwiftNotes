Это **фреймворк**, построенный **поверх UIKit**, позволяющий сохранить **плавность** и **отзывчивость** даже в самых сложных интерфейсах. Чтобы это достичь, Texture позволяет вынести дорогостоящие операции(напр. декодирование изображений, вычисление позиций и т.п.) из основного потока, чтобы он не блочился и юзер мог с ним взаимодействовать. 

**Texture** предоставляет различные абстракции над стандартными UI элементами(например UIView, UIImage). Основные её элементы это узлы (Nodes) и контейнеры узлов (Node Containers).
	Максимальная производительность достигается только тогда, когда все узлы содержатся в контейнерах, потому что именно контейнеры отвечают за передачу состояний в узлы. Использование узлов вне специальных контейнеров не даст улучшения производительности, а так же может стать причиной мигания(flash) компонентов.
### Узлы (Nodes)
##### ASDisplayNode
ASDisplayNode – базовый класс который по сути, является абстракцией над UIView, аналогично как UIView является абстракцией над CALayer. Имеет те же свойства, что и UIView:
`let node = ASDisplayNode()`
`node.backgroundColor = .orange`
`node.bounds = CGRect(x: 0, y: 0, width: 100, height: 100)`
##### ASNetworkImageNode
ASNetworkImageNode - узел который позволяет отобразить **изображение**, которое размещается удаленно. Для этого нужно задать свойство URL и изображением будет **асинхронно** **загружено** и сразу же отрисовано.
`let imageNode = ASNetworkImageNode()`
`imageNode.style.preferredSize = CGSize(width: 300, height: 300)`
`imageNode.url = URL(string: "https://example.com/example.jpg")`
	ASNetworkImageNode - один из узлов, который не может высчитать свои размеры, поэтому их нужно указывать явно
##### ASScrollNode
ASScrollNode - это ASDisplayNode, основой которой ясвляется **UIScrollView**. Этот уpел может автоматически высчитывать своq размер (не нужно следить за размерами, когда добавляете новые узлы). При помощи свойства scrollableDirections можно менять направления прокрутки (при этом можно задать оба направления).
`let scrollNode = ASScrollNode()`
`scrollNode.automaticallyManagesSubnodes = true`
`scrollNode.automaticallyManagesContentSize = true`

`scrollNode.layoutSpecBlock = { node, constrainedSize in`
  `let stack = ASStackLayoutSpec.vertical()`
  `// Здесь можно добавить элементы в ASScrollNode при помощи свойства stack.children (массив)`
  `return stack`
`}`
##### Оборачивание UIKit элементов (View Wrapping)
Данный способ позволяет обернуть существующие представления если это потребуется (UIView -> ASDisplayNode).
`let nodeControl = ASDisplayNode { () -> UIPageControl in`
            `let dots = UIPageControl();`
            `dots.numberOfPages = 2;`
            `dots.currentPage = 1;`
            `return dots`
        `}`
### Контейнеры узлов (Node Containers)
Контейнеры узлов в автоматическом режиме управляют интеллектуальной предварительной загрузкой узлов (intelligent preloading). Это означает, что все вычисления расположений узлов, загрузка данных, декодирование и отрисовка будут выполняться асинхронно. Именно поэтому рекомендуется использовать узлы внутри контейнера узлов.

# Туториал по AsyncDisplayKit 2.0 (Texture): Начало работы
**AsyncDisplayKit** – это UI фреймворк, который был разработан и применен Facebook в приложении Paper. Он помог команде разработчиков Paper найти ответ на один из ключевых вопросов: как сохранить основной поток приложения максимально свободным.

Сейчас многие приложения основываются на пользовательском интерфейсе, который в значительной степени зависит от непрерывных движений и анимации на основе физики. По крайней мере, ваш UI, наверняка, базируется на каком-то из видов Scroll View.

Такие типы пользовательских интерфейсов полностью зависят от основного потока и чрезвычайно чувствительны к его тормозам. Нагруженный основной поток означает отброшенные фреймы и неприятный пользовательский опыт.

Основные факторы работы потока включают:
- **Measurement and Layout**: такие события, как вызов метода **heightForRowAtIndexPath:** или **sizeThatFits** класса **UILabel**, а также экспоненциальная стоимость расчета констрейнтов.
- **Image Decoding**: использование **UIImage** в режиме просмотра изображения означает, что данные изображения сначала должны быть декодированы.
- **Drawing**: сложный текст, а также отрисовка градиентов и теней вручную.
- **Object Life Cycle**: создание, управление и уничтожение системных объектов (т. е. cоздание **UIView**).