#Супер #шпаргалка по #Rx'у - https://habr.com/ru/articles/281292/
 **Реактивное программирование** — парадигма программирования, ориентированная на **потоки данных** и **распространение** **изменений****.
В императивном стиле мы пишем набор команд, которые должны выполняться последовательно. Реактивный стиль придерживается других концепций. При реактивном стиле наша программа является **"слушателем"** изменений состояний **у наблюдаемых объектов**. 
## Observable
Observable - наблюдаемый объект. Это то, что будет отдавать данные, он нужен для генерации потока данных. На него мы подписываемся и слушаем его изменения.
Создание Observable и подписка на него
```
let observable = Observable<String>.just("Первый observable")

_ = observable.subscribe { (event) in
    print(event)
}
```
В принте мы получим слеудющее:
	next(Первый observable)  
	completed
Observable отправляет нам информацию о своих event'ах, есть всего 3 вида:
- next
- error
- completed
Вместе с _next_'ом приходит элемент, который мы отправляли и все события посланные нами, _error_ посылается как понятно из названия в случае ошибки, а _completed_ в случае, когда наш observable отослал все данные и завершает работу.
Мы можем создать более детального ~~наблюдателя~~ **subscriber**'а и получить более удобный вид для обработки всех событий.
```
_ = observable.subscribe(onNext: { (event) in
    print(event)
}, onError: { (error) in
    print(error)
}, onCompleted: {
    print("finish")
}) {
    print("disposed") 
    //о том, что это такое и зачем это мы поговорим позже
}
```
Тип в таком случае BinaryDisposable, до этого был NonDisposable
В **observable** можно создавать последовательность не только из одной строки, да и вообще не только из строк, мы можем положить туда любой тип данных.
```
let sequence = Observable<Int>.of(1, 2, 4, 5, 6)

_ = sequence.subscribe { (event) in
    print(event)
}
```
В таком случае тип SinkDisposer
```
let array = [1, 2, 3]

let observable = Observable<Int>.from(array)

_ = observable.subscribe { (event) in
    print(event)
}
```
У одного _observable_ может быть сколь угодно много _subscriber'ов_.
**Observable** — это основа всего Rx, которая асинхронно генерирует последовательность неизменяемых данных и позволяет подписываться на нее другим.
## Disposing
Теперь, когда мы умеем создавать последовательность и подписываться на них, необходимо разобраться с такой штукой, как **_disposing_**.

Важно помнить, что **_Observable_** это "**холодный**" тип, то есть наш observable не "испускает" никаких событий, **пока на него не подпишутся**. Observable **существует** до тех пор, **пока он не пошлет сообщение об ошибке** (_error_) или **сообщение о завершении** (_completed_). Если мы хотим явно отменить подписку, то можем сделать следующее.
```
//вариант №1

//создали массив значений
let array = [1, 2, 3]

//создали observable из массива значений
let observable = Observable<Int>.from(array)

//создали подписку на observable
let subscription = observable.subscribe { (event) in
    print(event)
}

//dispos'им нашу одноразовую подписку
subscription.dispose()
```
Есть более ~~красивый~~ правильный вариант.
```
//создаем сумку "утилизации"
let bag = DisposeBag()
//создали массив значений
let array = [1, 2, 3]

//создали observable из массива значений
let observable = Observable<Int>.from(array)

//создали подписку на observable
_ = observable.subscribe { (event) in
    print(event)
}.disposed(by: bag)
```
Таким образом мы добавляем нашу подписку в сумку утилизации или в **_DisposeBag_**.  
Для чего это нужно? Если вы, используя подписку, **не добавите ее в сумку** или **явно не вызовете _dispose_**, ну или в крайнем случае не приведете каким-то образом **_observable_ к завершению**, то скорее всего вы **получите** **утечку** **памяти**. DisposeBag вы будете использовать очень часто в своей работе с RxSwift.

## PublishSubject
`PublishSubject` не сохраняет свое состояние и начинает передавать события только после того, как подписчик подписался на него. Это значит, что подписчики получают только те события, которые были отправлены после их подписки.
[Open: Pasted image 20240626164829.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/69dd36b3cb84c1cdcbe8d3ea5ac5c73e_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/69dd36b3cb84c1cdcbe8d3ea5ac5c73e_MD5.jpeg)
## PublishRelay
`PublishRelay` очень похож на `PublishSubject`, но он **никогда не завершает и не генерирует ошибки**. Это значит, что он **всегда** **активен** и **не может завершиться с ошибкой.**ф
[Open: Pasted image 20240626164939.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/7f4c4487dc249fa919f744fdcf85b4c2_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/7f4c4487dc249fa919f744fdcf85b4c2_MD5.jpeg)
## BehaviorSubject
`BehaviorSubject` хранит последнее переданное значение и сразу же отправляет его новым подписчикам при подписке. Это означает, что подписчики сразу получают последнее значение, даже если они подписались позже.
[Open: Pasted image 20240626165248.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/e07f99ae3c7da880fe20a141be7859c6_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/e07f99ae3c7da880fe20a141be7859c6_MD5.jpeg)
## BehaviorRelay
`BehaviorRelay` похож на `BehaviorSubject`, но он никогда не завершает и не генерирует ошибки. Он также хранит последнее переданное значение и отправляет его новым подписчикам.
[Open: Pasted image 20240626165537.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/8e65bed5c63086f6517ec10f4e0afbb8_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/8e65bed5c63086f6517ec10f4e0afbb8_MD5.jpeg)

## Что делает `subject.onNext()`
Метод `onNext(_:)` используется для отправки нового значения подписчикам. Когда ты вызываешь `onNext(_:)` у `PublishSubject` или любого другого типа `Subject`, все подписчики, которые подписались на этот `Subject`, получат это новое значение и их замыкания (`closures`) будут выполнены с этим значением.
# Разница между Observable и Subject
### Observable

`Observable` (наблюдаемый) — это основная сущность в RxSwift, которая представляет поток данных или событий, на которые можно подписаться. `Observable` создаёт и управляет асинхронными последовательностями данных. Основные моменты о `Observable`:

- **Однонаправленность**: `Observable` передает данные подписчикам (наблюдателям), но не принимает данные от них.
- **Создание**: `Observable` может быть создан различными способами, например, из массивов, событий или асинхронных операций.
- **Подписка**: Подписчики (наблюдатели) подписываются на `Observable` и получают данные, когда они доступны.
### Subject

`Subject` — это особый тип `Observable`, который позволяет как подписываться на него, так и передавать данные. `Subject` действует как мост или прокси, передавая значения своим подписчикам. Основные моменты о `Subject`:

- **Двунаправленность**: `Subject` может принимать данные (через методы `onNext`, `onError`, `onCompleted`) и передавать их подписчикам.
- **Подписка**: Подписчики могут подписаться на `Subject`, как и на любой другой `Observable`.
- **Типы**: Существует несколько типов `Subject`, каждый из которых имеет свои особенности.
## Виды Subject'ов помимо упомянутых выше
#### ReplaySubject
`ReplaySubject` сохраняет буфер из последних переданных значений (или все значения) и отправляет их новым подписчикам при подписке.
[Open: Pasted image 20240626170927.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ba86007348d87de3fb62747a30e1d6cd_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ba86007348d87de3fb62747a30e1d6cd_MD5.jpeg)
#### AsyncSubject
`AsyncSubject` передает только последнее значение (если было отправлено событие завершения `onCompleted`) своим подписчикам.
[Open: Pasted image 20240626171010.png](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/4fdf904de87214de429876c90170983e_MD5.jpeg)
![](Swift/SwiftBasis/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/4fdf904de87214de429876c90170983e_MD5.jpeg)
### Подытожим
- **Observable**: Только передает данные подписчикам.
- **Subject**: Может как передавать, так и принимать данные, являясь одновременно `Observable` и `Observer`.
- **PublishSubject**: Не сохраняет состояние, передает только новые события подписчикам.
- **BehaviorSubject**: Хранит последнее значение и передает его новым подписчикам.
- **ReplaySubject**: Хранит буфер из последних значений и передает их новым подписчикам.
- **AsyncSubject**: Передает только последнее значение (если было событие завершения).
- **PublishRelay**: Как `PublishSubject`, но не может завершиться с ошибкой или обычным завершением.
- **BehaviorRelay**: Как `BehaviorSubject`, но не может завершиться с ошибкой или обычным завершением.
### Scheduler 
Scheduler позволяет задиспозить Observable после какого-то времени.
