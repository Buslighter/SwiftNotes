![Pasted image 20240429124212](Swift/Многопоточность/Stepik/Скриншоты/Pasted%20image%2020240429124212.png)
#### Зачем вообще нужна многопоточка?
В современных приложениях существуют **операции**, которые **выполняются продолжительное время**, например обращение к бэку или бизнес-логика. Нам **нужно разгрузить главный поток** и вынести такие операции в бэкграунд поток 
**Main Thread** (Главный поток) - это поток, в котором стартует наше приложение, все **взаимодействия с UI** происходят на нем.
![Pasted image 20240429124435](Swift/Многопоточность/Stepik/Скриншоты/Pasted%20image%2020240429124435.png)
Основной примитив многопоточности - поток.
#### pthread
pthread - unix поток, самый низкоуровневый примитив
`var thread = pthread_t(bitPattern: 0) -- поток`
`var attr = pthread_attr_t() -- атрибут` 

`pthread_attr_init(&attr)` -- инициализция атрибута, привязка указателя
`pthread_create(&thread, &attr, { pointer in` 
	`print("test")`
	`return nil`
`}, nil)` -- создание потока, как только он создается - начинается его выполнение
Но если создать 2 pthread, не гарантируется выполнется сначала первый блок или второй
`let thread1 = Thread {`     
	`print("test1")`     
	`let thread2 = Thread {`
			`print("test2")`     
		`}`     
		`thread2.start()` 
	`}`
	           
`thread1.start()`
Сначала начнет выполнение 1-ый поток, только после этого в нем создатся второй поток и начнет свое выполнение
#### Thread
Thread - objc обертка над unix потоком, которая позволяет создать поток проще, чем pthread
`var nsthread = Thread(block: {` -- создание потока, в конструкте в block мы передает кложуру, в данном случае просто print
	`print("test")`
`})`
`nsthread.start()` -- запуск