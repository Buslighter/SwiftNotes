Частая проблема - есть ресурс Shared Resource и к нему одновременно обращаются 3 разных потока, в такой ситуации может произойти коллизия, когда один потом поменял данные, а другой читает.
![Pasted image 20240429152717](Swift/Многопоточность/Stepik/Скриншоты/Pasted%20image%2020240429152717.png)
С помощью синхронизации мы можем обеспечить одновременный доступ 1-го или нескольких потоков в ресурсу. Существует 2 основных примитива синхронизации mutex и semaphore.
#### Mutex
Mutex разрешает обращаться к ресурсу только одному потоку за раз. 
pthread_mutex

`private var mutex = pthread_mutex_t()`

`pthread_mutex_init(&mutex, nil)`
`pthread_mutex_lock(&mutex)` -- захватили ресурс, подразумевается, что когда один поток захватил ресурс, никакой другой поток не может к нему обратиться
`//Do something`
`pthread_mutex_unlock(&mutex)` -- отпустили ресурс
##### NSLock
NSLock - это mutex в Swift из фреймоврка Foundation
`private let lock = NSLock()`
`lock.lock()`
`//Do Something`
`lock.unlock`

Recursive pthread_mutex - позволяет делать повторный lock, позволяет потоку захватывать ресурс повторно, система отслеживает след захватов, используется в рекурсивных функциях
NSRecursiveLock - позволяет делать повторный lock
#### Semaphore
Semaphore позволяет обращаться к ресурсу сразу с нескольких потоков.
