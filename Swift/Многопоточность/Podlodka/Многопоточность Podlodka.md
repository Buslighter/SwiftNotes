#### Timeline
2000 - Apple выпускает открытую unix-like **OC Darwin**
2001 - Apple выпускает **Mac OS X** 10.0 на базе Darwin
2007 - Apple выпускает **iPhone OS** на базе Mac OS

## Darwin
Darwin - юниксо-подобная ось, которая представляет модель потоков и процессов как в unix-е

**Процесс** - абстракция, описывающая выполняющуюся программу, в рамках iOS инфраструктуры каждая app - это процесс, эти процессы могут общаться через передачу сообщений, механизм message passing. Процессы внутри делятся на потоки.

**Поток** - мини версия процесса, находящаяся внутри процесса, общение между потоками происходит по средствам разделяемой памяти внутри процесса.
#### Context switch.
Context switch - переключение между потоками.
На одном ядре не может выполняться несколько задач одновременно, но благодаря потокам мы имитируем параллельное выполнение задач. Время на выполнение потока распределяется порционно. Но при этом, если **у устройства 2 ядра**, то задачи могут выполняться реально параллельно, но это **не гарантируется!**
![Pasted Graphic](Swift/Многопоточность/Podlodka/Скриншоты/Pasted%20Graphic.png)
#### POSIX
Portable Operating System Interface For Unix (POSIX) - набор стандартов, который описывает интерфейсы взаимодействия между ОС и программами, которые в ней запускаются. Реализация POSIX потоков называется **pthreads**.
**pthreads** - это библиотека на С для манипуляции потоками.

#### XNU
В основе Darwin лежит ядро XNU.  Состоит из двух слоев **mach** и **bsd**.
![Pasted image 20240426163751](Swift/Многопоточность/Podlodka/Скриншоты/Pasted%20image%2020240426163751.png)
#### Mach
Mach - микроядро, отвечает за
- Абстракции над процессами и потоками, процессы не выполняются напрямую, а представляют собой task'и, что позволяет распределять временные ресурсы процессора напрямую на потоки
- Менеджмент виртуальной памяти
- Планирование задач(Task scheduling)
- Inter Procces Communication(IPC) - механизм общения между потоками в разных процессах
#### BSD
BSD - слой, который предоставляет
- Модель процессов UNIX
- Модель тредов POSIX - pthreads и примитивы синхронизации
- Network stack и другие высокоуровневые абстракции
#### Вывод
1. Вместо процессов у нас исполняемые таски
2. pthreads для манипуляции потоками и примитивы синхронизации потоков
3. Потоки - главные действующие лица
#### Pthreads
pthreads - API на языке С, использование в iOS возможно, но по официальной документации - не рекомендуется!
#### Thread
Thread - это обертка над pthread'ом на уровне языка. Наследник NSObject. 
Thread состоит из:
[Open: telegram-cloud-photo-size-2-5305663544626370783-y.jpg](Swift/Многопоточность/Podlodka/Скриншоты/6e181256e2e78802255269b11b9623c3_MD5.jpg)
![](Swift/Многопоточность/Podlodka/Скриншоты/6e181256e2e78802255269b11b9623c3_MD5.jpg)
## Runloop
**Runloop** - это часть инфраструктуры системы, которая **слушает события** из двух типов источников - TimersSources, InputSources. Главная **фишка** runloop'а - **пока есть работа,** он **держит thread** в занятом состоянии, если **работы нет**, то погружает **поток в сон**. Это позволяет системе не отзывать поток( не уничтожать его полностью). **Поток спит** - это значит, что он **не требует никаких ресурсов от системы** и **не блокирует** выполнение других задач. 
Не у каждого потока есть Runloop. У main потока есть Runloop, у других надо запускать самому с помощью метода run(). На один поток приходится один Runloop.
[Open: telegram-cloud-photo-size-2-5305663544626370793-y.jpg](Swift/Многопоточность/Podlodka/Скриншоты/bb6d55cd029c7812344f9c97e6526cad_MD5.jpg)
![](Swift/Многопоточность/Podlodka/Скриншоты/bb6d55cd029c7812344f9c97e6526cad_MD5.jpg)
[Open: telegram-cloud-photo-size-2-5305663544626370806-y.jpg](Swift/Многопоточность/Podlodka/Скриншоты/a439cd66f79410699db726c360080253_MD5.jpg)
![](Swift/Многопоточность/Podlodka/Скриншоты/a439cd66f79410699db726c360080253_MD5.jpg)
#### Проблемы Threading
Подход порождает множество проблем, которые сложно обнаружить.
### Race Condition
Вынуждает обращаться к механизмам синхронизации потоков. За счет того, что потоки общаются через разделяемую память происходит состоянии гонки.
В примере ниже происходит состояние гонки: есть счетчик, который имплементируется с разных потоков, может произойти ситуация, когда два потока будут считывать одно и тоже значение, произведя двойную работу, но увеличив всего на один, вместо двух.
[Open: telegram-cloud-photo-size-2-5305663544626370809-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ad12a82e1f38108a5c1a8f2a9a62f482_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ad12a82e1f38108a5c1a8f2a9a62f482_MD5.jpg)

### Deadlock, livelock, performance penalty
**Deadlock** - это когда два потока пытаются перехватить блокировку друг у друга и ждут друг-друга бесконечно. 
**Livelock** - потоки перекидываются работой между собой, но никто ее не выполняет и система работает в холостую.
[Open: telegram-cloud-photo-size-2-5305663544626370813-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/2a18b1ad703972050acb298150055b51_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/2a18b1ad703972050acb298150055b51_MD5.jpg)
Performance penalty - это просто понятие, что ухудшается перформанс программы.

### Priority inversion, starvation
Для iOS такие проблемы редки. Это ошибки менеджмента потоков.
**Priority inversion** - это когда низкоприоритетный поток выполняет свою работу или получает доступ к заблокированной критической секции раньше, чем высокоуровневый поток. То есть задачи с большим приоритетом выполняются после задач с меньшим.
**Starvation** - поток пытается получить доступ к критической секции, к заблокированной секции к lock'у, но не получается сделать в доступные окошки. Он тратит ресурсы ОС, но так и не приступает к задаче, потому что не попадает в эти окна.
[Open: telegram-cloud-photo-size-2-5305663544626370823-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/3cbacbaf5ca0b965d4c68e26dee643bf_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/3cbacbaf5ca0b965d4c68e26dee643bf_MD5.jpg)

## Concurrency != parallelism
**Parallelism** - это фактическое параллельное выполнение задач.
**Concurrency** - это возможность задач выполняться параллельно, не гарантируется!

### 2 типа concurrency
- Shared memory - на разделенной памяти, тут главные лица потоки.
- Message passing - на основе message passing'а, механизм с помощью которого процессы общаются друг с другом.
## Actors model
Математическая модель, основанная на передаче сообщений, в которой примитивным вычислительным юнитом является actor.
Можно использовать ключевое свойство вместо class, чтобы сделать свойства класса атомарными. **Атомарность** - действие над свойством происходит в один процессорный такт.
**Actor** - это сущность, которая содержит ID, приватное состояние, почтовый ящик для входящих сообщений.
Что умеет Actor? :
- Принимать сообщения
- Получать сообщения
- Работу работать
Акторы выполняют работу используя потоки. Можно добиться того, чтобы на одном потоке, который уходит в ОС будет выполняться множество акторов.
[Open: telegram-cloud-photo-size-2-5305663544626370849-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/16d4fff36dfa32e87a1a7019c9c33d07_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/16d4fff36dfa32e87a1a7019c9c33d07_MD5.jpg)
Программы на акторах хорошо масштабируются, позволяют строить надежные распределенные программы. Нет общего состояния, поэтому прощайте синхронизации, тем не менее все еще можно получить deadlock'и.

## Что есть Native метод?
## Grand Central Dispatch
**GCD** - технология, которая **позволяет** **выполнять** задачи **асинхронно**. **Отвечает** за **менеджмент** потоков. **Планирует** выполнение задач на **потоках**, в зависимости от загруженности ОС.
Понятия:
- Задача - DispatchWorkItem
- Очередь - DispatchQueue
- Synchronous, asynchronous
DispatchWorkItem - это работа, которую нужно выполнить, в самом простом случае это closure(блок). 
WorkItem имеет qos - приоритет выполнения.
WorkItem можно отменить, пока его не взял в работу, с помощью cancel.
### DispatchWorkItemFlags.Barrier
Задача с этим флагом является барьерной задачей. Это значит, что очередь не будет обрабатывать задач до тех пор, пока барьерная задача не будет выполнена.
[Open: telegram-cloud-photo-size-2-5305663544626370863-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/4a755e5aa3d1dd1e3a86d997cdcaf83d_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/4a755e5aa3d1dd1e3a86d997cdcaf83d_MD5.jpg)
Решает проблему разделения тасок на логический блок между ними.
### DispatchQueue
**DispatchQueue** - очередь, занимается распределение и работой над потоками, объект, который  **управляет** **выполнением** задач на главном или фоновом потоке. Работает по типу FIFO - first in first out, то есть очередь. 
Бывает двух типов:
- **serial**
- **concurrent**
#### Serial
Это последовательная очередь, которая **выполняет задачи одна за одной**. Из примеров - **приватные очереди**, которые мы **создаем вручную**, также **main queue** является serial очередью, **на ней работает UI** и UIKit. С учетом своей специфики serial очереди могут служить точкой синхронизации в многоочередийном программировании, **sync** на главной очереди приведет к **deadlock**.
[Open: telegram-cloud-photo-size-2-5305663544626370873-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/7779bb4b7c0a811a4671b0550f680e9e_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/7779bb4b7c0a811a4671b0550f680e9e_MD5.jpg)
#### Concurrent
Можем создать в ручную, а также 4 глобальные очереди, предоставленные системой. **Особенность** очереди в том, что она **берет в выполнение столько задач**, сколько может, **в зависимости от загруженности** системы. **Выполняет** **несколько задач** **на разных потоках**. sync **также** может привести к **deadlock**'у, даже на concurrent очереди.
[Open: telegram-cloud-photo-size-2-5305663544626370876-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/1a61d0f58cfe76e1fc0975c34b9937fd_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/1a61d0f58cfe76e1fc0975c34b9937fd_MD5.jpg)

#### sync
У очереди есть 2 способа взять задачу в работу, может взять задачу синхронно, то есть берем задачу в очередь и ждем когда она выполнится.
queue.sync{...} - помещаем задачу в очередь, ждем выполнения.
[Open: telegram-cloud-photo-size-2-5305663544626370894-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/db0675f6b462b2c37ba54157acfca506_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/db0675f6b462b2c37ba54157acfca506_MD5.jpg)
#### async
Второй вариант поместить задачу асинхронно, мы не ждем выполнения задачи, просто положили ее и идем дальше выполнять в текущей очереди что-то другое.
queue.async{...} - помещаем задачу в очередь, не ждем выполнения.

[Open: telegram-cloud-photo-size-2-5305663544626370895-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/95f86138a411bfe591f7d2feecc808fb_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/95f86138a411bfe591f7d2feecc808fb_MD5.jpg)

## GCD in Depth
1) WorkItem поступает на работу в очередь
2) Очередь достает WorkItem и запрашивает у системы поток для выполнения WorkItem'а
3) Система в зависимости от нагрузки выделяет поток на выполнения WorkItem'а, система использует для этого паттерн thread pool. Суть thread pool'а в том, что вместо того, чтобы по запросу создавался поток, потоки создаются заранее и по мере надобности они выдаются, также их можно переиспользовать
[Open: telegram-cloud-photo-size-2-5305663544626370898-y.jpg](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/08cb90e51df7d4b9e8a5bbecfec10106_MD5.jpg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/08cb90e51df7d4b9e8a5bbecfec10106_MD5.jpg)

#### Что умеет GCD
#### DispatchGroup
DispatchGroups - мониторим выполнение набора задач. Полезно, когда инфа запрашивается от нескольких источников и нужно трекнуть когда они все выполняться.
#### DispatchSemaphore
DispatchSemaphore - для ограничения доступа к ресурсу. 
#### DispatchSources
DispatchSources - источники данных для DispatchQueue, нужны чтобы правильно слушать и реагировать на системные события, нужны редко.
#### queue.concurrentPerform(iterations:execute:)
Мы указываем кол-во итераций и блок кода, который должен выполнится и система сама распараллеливает этот цикл в зависимости от нагрузки.
#### Проблемы GCD
Хотя очереди **потокобезопасны**, важно помнить:
- избагать **sync**-вызова на очередях
- избегать **захвата блокировок** внутри DispatchWorkItem
- RaceCondition все еще есть

## Operations
operations - задачи-объекты,  которые выполняются в OperationQueue.
(NS)Operation - абстрактный класс, который олицетворяет работу, которую нужно сделать. Система предоставляет 2 системных подкласса:
- NSInvocationOperation
- BlockOperation
Метод start запускает выполнение операции в текущем потоке. Задачи, которые помещены в очередь исполняются на отдельных потоках. OperationQueue может работать напрямую на потоках, а также с помощью GCD очередей.
- Можно выстраивать зависимости операций друг от друга, похоже на группы в GCD, но здесь они выполняются по цепочке.
- Можно отменять операции в процессе выполнения
- CustomOperations - для полного контроля над операцией
CustomOperation:
sync
Если операция синхронная, то нужно переопределить метод main. Не забыть синхронизировать доступы к данным операциям.
async
нужно переопределить метод start, переопределить свойства isAsynchronous, isExecuting,isFinished, isCanceled. Поддержать KVO-нотификации в ответ на изменение состояния операции. Кароче сложно выходит.

Проблема
## Callback-hell
[Open: completionBlock(1mageResult).png](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/c0538fee73c4db4b5bf33074679f5f43_MD5.jpeg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/c0538fee73c4db4b5bf33074679f5f43_MD5.jpeg)
Видно, что код не читаемый из-за вложенности, каждая кложура вызывает функцию в функции.
Как избежать вложенности? Ответ - обещания. Ждем обещания. Обещанный результат
[Open: Например, вот так.png](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/e54b48e701d059bde32712e505b2fb42_MD5.jpeg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/e54b48e701d059bde32712e505b2fb42_MD5.jpeg)
Очень похоже на async/await.
**Promise** - объект, к которому можно обратиться за результатом, вычисление которого может быть еще не завершено.
## Async/await
**async/await** - синтаксическая особенность некоторых языков, которая позволяет структурировать **неблокирующие** асинхронные функции как обычные синхронные.

**Сопрограмма** (coroutine) - компонент, который может приостанавливать свою работу, сохраняя все свое текущее состояние в момент остановки. В самом простом случае - это функция, которая содержит один **return** и куча **suspend** точек, которые приостанавливают программу. Тем самым можно переключаться между функциями, приостанавливая их, не тратя ресурсы и тем самым они не блокируют поток выполнения. 
[Open: Итоговый код может выглядеть так.png](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ec15e694d7a0d425dc7a2e456c87dfd0_MD5.jpeg)
![](Swift/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C/Podlodka/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/ec15e694d7a0d425dc7a2e456c87dfd0_MD5.jpeg)
Основную функцию делаем async, остальные приписываем await и вызываем одну за другой.

## Swift concurrency
Что обещают к 6-ой версии Swift и что немного можно попробовать.
### Swift-atomics
Swift-atomics - для реализации механизмов синхронизации
### Async/Await
async/await - на корутинах, акторах
### Task API, Structured Concurrency и много чего еще



# Queue

Начало очереди
2 thread'а
sync task -> thread 1, queue freeze -> queue free
async task -> thread 1
async task -> thread 2
sync task

