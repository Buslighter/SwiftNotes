### Ссылка
В Swift типы данных можно разделить на value и reference. Reference типы передаются по ссылке. Value тип хранится в стэке, reference в куче. Стэк работает быстрее, потому что он на стэкэ, а куча это древовидная структура. Ссылка представляет собой ту же ссылку, что и в Си.
Но как ссылки освобождаются из памяти? Во многих языках есть garbage collector, в Си ручное управление памятью. Раньше, когда писали на Obj-c тоже приходилось освобождать объекты из памяти с помощью **MRC**. 

**Manual Reference Counter** - обладал двумя основными функциями, позволяющими увеличивать счетчик ссылок на объект в памяти - **retain** и уменьшать - **release**. 

Комментарии:
Во время компиляции ARC отрабатывает. Проставляет флаги retain/release. Под вопросом - когда они освобождаются и перемещаются в autorelease pool.

Но в последних версиях  появился **ARC** - Automatic Reference Counter, который избавил нас от необходимости проставлять собственноручно retain и release, он делает это за нас. **ARC** отслеживает количество ссылок на объект и автоматически освобождает память, когда объект больше не имеет ни одной ссылки на него. Каждый раз, когда вы создаете новый экземпляр класса (или структуры), ARC увеличивает счетчик ссылок на этот экземпляр. Когда объект больше не нужен (когда количество ссылок становится равным нулю), ARC освобождает память, высвобождая ресурсы, занимаемые объектом. ARC берет на себя ответственность за управление памятью. Это снижает вероятность утечек памяти и упрощает процесс разработки приложений.

#### ARC работает на этапе выполнения программы.
Во время runtime ARC отслеживает количество активных ссылок на каждый объект в памяти. Когда количество ссылок на объект становится равным нулю, ARC автоматически освобождает память, занимаемую этим объектом, вызывая деструкторы объектов и возвращая выделенную память обратно в систему.
#### Что делает ARC во время компиляции?
На этапе **компиляции** ARC в Swift **генерирует инструкции для управления памятью**, которые встраиваются непосредственно в скомпилированный код. В частности, ARC определяет, когда должны быть добавлены **инструкции для увеличения** или уменьшения **счетчика** **ссылок** на объекты.
#### Это сборщик мусора?
 Система использует подход «подсчета ссылок», который является частью техники управления памятью, известной как сборка мусора. Однако, **в отличие от традиционной сборки мусора**, которая выполняет сборку периодически или по запросу, **ARC** **освобождает память немедленно**, когда объект больше не нужен. То есть сборщик мусора работает в RunLoop'е, а ARC освобождает память сразу. Также выполняет некоторые оптимизации на этапе компиляции для улучшения производительности, например может оптимизировать область видимости объекта и освободить память, когда объект далее не используется в пределах этой области.

#### Retain Cycle.
Но ARC не всемогущ и например retain cycle(объекты ссылаются друг на друга) он самостоятельно разрешить не сможет, объекты будут жить бесконечно. Чтобы решить эту проблему в Swift добавили **weak** - ссылки. Ссылки, про которые мы говорили до являются strong ссылками, ARC освобождает объект основываясь на их количестве. **weak** ссылка позволяет нам не увеличивать счетчик сильных ссылок на объект, благодаря чему ARC сможет освободить объект из памяти и не будет retain cycle.

- `strong ссылка` удерживает объект и не позволяет ему быть deallocated, пока эта сильная ссылка существует.
    
- `weak ссылка` это ссылка, которая не удерживает объект, на который она ссылается, и поэтому не мешает ARC освободить этот объект.
    
- `unowned ссылка` как и слабая, не удерживает объект. Но в отличии от weak, в ней нет проверки на то, что счетчик уже 0, что может вызвать runtime error.

[Open: Pasted image 20240705203615.png](Swift/iOS%20Club%20S_21/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/08ef0d1dacec10f343df5601ea1b9465_MD5.jpeg)
![](Swift/iOS%20Club%20S_21/%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%D1%8B/08ef0d1dacec10f343df5601ea1b9465_MD5.jpeg)
Использование unowned ссылки допускается, только когда мы уверены, что ссылаемый объект переживет ссылку, для того, чтобы пропустить проверку опционала.